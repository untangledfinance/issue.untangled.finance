import{k as I,r as i,d as R}from"./index-BUY2Cjej.js";import{f as q,P as k}from"./index-YDRpzjTi.js";import{cb as b,bg as y,c4 as A}from"./vendor-WQejLG7Y.js";const o={createUpdatePoolScorecard:"/api/v1/pool/:poolId/scorecard",createUpdateScorecard:"/api/v1/scorecard",getSetupScoreCardParam:"/api/v1/pool/:poolId/setup-scorecard-params",updateSetupRiskScoreTxHash:"/api/v1/pool/:poolId/update-setup-riskscore-txhash",getPoolScorecards:"/api/v1/pool/:poolId/scorecards",getScorecards:"/api/v1/scorecards",getActiveScorecards:"/api/v1/active-scorecard",createUpdateScorecardBatch:"/api/v1/pool/:poolId/scorecard/batch",deletePoolScorecard:"/api/v1/pool/:poolId/scorecard/:id",deleteScorecard:"/api/v1/scorecard/:id"};class C{async setScorecardsToContract(e,t,r){const a=await q(e),s=[],n=[],l=[],u=[],p=[],d=[],S=[],g=[],h=[],f=[],m=[];t.forEach(c=>{s.push(c.daysPastDue*24*60*60),n.push(c.advanceRate*1e4),l.push(c.penaltyRate*1e4),u.push(c.interestRate*1e4),p.push(c.discountRate*1e4),g.push(Math.round(c.gracePeriod*24*60*60)),h.push(Math.round(c.collectionPeriod*24*60*60)),d.push(c.probabilityOfDefault*1e4),S.push(c.lossGivenDefault*1e4),f.push(Math.round(c.writeOffAfterGracePeriod*1e4)),m.push(Math.round(c.writeOffAfterCollectionPeriod*1e4))});const P=[...n,...l,...u,...d,...S,...p],w=[...g,...h,...f,...m],v=await a.methods.setupRiskScores(s,P,w).estimateGas({from:r});return await a.methods.setupRiskScores(s,P,w).send({from:r,maxPriorityFeePerGas:null,maxFeePerGas:null,gasLimit:parseInt(v.toString())+1e6})}async updateBatchAssetRiskScore(e,t,r){try{const a=await q(e),s={address:e,abi:k.abi},n=t.map(d=>({...s,functionName:"risk",args:[d]})),u=(await b(I,{allowFailure:!0,contracts:n})).map(d=>d.result.toString()),p=await a.methods.batchUpdateAssetRiskScore(t,u).send({from:r,maxPriorityFeePerGas:null,maxFeePerGas:null});return y.success({message:"Success",description:"Update risk score for assets successfully!"}),p}catch(a){console.error("Error update scorecards",a),y.error({message:"Error",description:"Failed to update asset risk score"})}}async createUpdateScorecardsBatch(e,t){const a=await(await i.getRequestInstance()).post(o.createUpdateScorecardBatch.replace(":poolId",e),t),{data:s}=a;return s}async getActiveScorecards(){const t=await(await i.getRequestInstance()).get(o.getActiveScorecards),{data:r}=t;return r}async createScoreCard(e,t){const a=await(await i.getRequestInstance()).post(t?o.createUpdatePoolScorecard.replace(":poolId",t):o.createUpdateScorecard,e),{data:s}=a;return s}async updateScoreCard(e){const{id:t,...r}=e;return(await i.getRequestInstance().patch(`api/v1/scorecard/${t}`,r)).data}async getSetupRiskScoreParam(e,t){const r=await i.getRequestInstance(),a=o.getSetupScoreCardParam.replace(":poolId",t),s=await r.get(a+`?${A.stringify({filter:{chainId:R.chainId}})}`,e),{data:n}=s;return n}async updateSetupRiskScoreTxHash(e,t){const a=await(await i.getRequestInstance()).post(o.updateSetupRiskScoreTxHash.replace(":poolId",t),e),{data:s}=a;return s}async getScorecards(e){const r=await(await i.getRequestInstance()).get(e?o.getPoolScorecards.replace(":poolId",e):o.getScorecards),{data:a}=r;return a}async deleteScorecard(e,t){const a=await(await i.getRequestInstance()).delete(t?o.deletePoolScorecard.replace(":poolId",t).replace(":id",e):o.deleteScorecard.replace(":id",e),{chainId:R.chainId}),{data:s}=a;return s}}const F=new C;export{F as s};
